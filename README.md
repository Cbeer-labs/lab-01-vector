# Лабораторная работа 7

## Цель
Цель работы:
* повысить навыки написания обобщенного кода
* усвоить "внутренности" STL библиотеки
* узнать об инженерной составляющую, которая позволяет повысить эффективность кода за счет различных приемов (в частности об амортизированной сложности)
* получить навыки написания итераторов для пользовательского контейнера

## Теоретическая часть

Едиственный дополнительный момент, который необходимо узнать до выполнения работы, - это узнать об амортизированной сложности метода `push_back`. Все остальные знания для выполнения лабораторной работы были изучены в предыдущих работах.

**Полезные ссылки:**
- [Выделение памяти под vector](http://alenacpp.blogspot.com/2005/06/vector_30.html)
- [Амортизированная сложность](https://www.coursera.org/lecture/c-plus-plus-red/amortizirovannaia-slozhnost-sGVxq)

## Задание

1. Реализуйте аналог `std::vector`.
1. Обеспечте **амортизированную сложность O(1)** добавления элемента в конец вектора.
1. Реализуте модульные тесты для вашего класса. Миниальное покрытие кода должно превышать 85%.
1. Проверьте код на наличие утечек памяти.
1. **Использовать `std::vector` запрещается.**
1. Следует использовать стандартные типы исключений из библиотеки `<stdexcept>`.
1. Проверьте, что ваша реализация правильно работает со стандартными алгоритмами STL (`std::sort`, `std::copy_if`, `std::find_if`).

### Методы для реализации
```cpp
template <class T>
class vector
{
public:
    vector();
    Конструктор копирования
    vector(size_t, const T&);
    ~vector();
    оператор присваивания

    operator[]
    at
    front
    back
    data

    begin
    end

    empty
    size
    reserve
    capacity

    clear
    insert
    push_back
    pop_back
    swap
};
```
