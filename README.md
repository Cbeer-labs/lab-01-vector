# Лабораторная работа 1

## Цель
Цель работы:
* познакомиться с классами
* повысить навыки написания обобщенного кода
* усвоить "внутренности" STL библиотеки
* узнать об инженерной составляющую, которая позволяет повысить эффективность кода за счет различных приемов (в частности об амортизированной сложности)
* получить навыки написания итераторов для пользовательского контейнера

## Теоретическая часть

### ООП

__Объектно-ориентированное программирование__ - парадигма программирования, где упрощение программного кода происходит за счёт дробления кодовой базы на независимые, изолированные части. Куски логической структуры программы и связанные с ними данные разбиваются на __классы__. Классы инстанцируются в различные наборы данных - __объекты__. Конечное взаимодействие "пользователя" класса заключается в инстанцировании этого класса в объект и изолированном взаимодействии с этим объектом через __методы__.

Изначально ООП был задуман как способ хранения данных в куче, и это в полном объёме представлено библиотекой контейнеров STL C++. В этой лабораторной работе вам предстоит познакомиться с внутренней реализацией контейнера `vector`.

### Классы (aka структуры)

Классы - основополагающая сущность в ООП. В C++ классы практически не отличаются от структур, с которыми вам уже приходилось сталкиваться в первом семестре курса. Фактически единственное отличие классов от структур в C++ - это спецификатор доступа по-умолчанию: в `struct` это `public`, а в `class` - это `private`. В рамках ООП принято использовать `class`.

В ООП принято считать, что с объектами стоит взаимодействовать через __методы__. __Методы__ - это функции, которые тесно взаимодействуют с полями класса. Из того, с чем вы уже наверняка успели подружиться, есть методы `std::vector`: `push_back()`, `begin()`, `end()`. В идеале ООП подразумевает полную изоляцию внутренних полей - это называется __энкапсуляция__. Для создания метода, нужно создать функцию внутри класса:

```cpp
class MyClass {
	int my_field;
public:
	int get_my_field() {
		return my_field;
	}
};
```

В данном случае метод `get_my_field()` - типичный пример геттера (метод, возвращающий значение поля).

Ранее упомянутая цель хранить данные в куче привносит некоторые проблемы: память, выделенную на куче в C++ необходимо собственноручно освободить эту память. В C++ используется концепт __RAII__: Resource Aquisition Is Initialization

Основные правила RAII:

1. Инициализация структуры (даже если она не связана с созданием объекта) приводит к выделению памяти
2. Дополнительные выделения памяти должны быть локализованы в методах
3. Если есть случай, когда объект существует с невыделенной памятью, нужно убедиться, что везде этот случай успешно обрабатывается
4. Прекращение существования объекта (например, выход его из области видимости) приводит к освобождению памяти

### Шаблоны

Уже раньше упоминалось, что `std::vector` - это класс. Прозорливый глаз мог заметить, что `std::vector` может хранить абсолютно любой тип данных, и при этом программисту не приходится каждый раз переписывать половину всего что есть в этой библиотеке

Этого позволяют достигнуть __шаблоны__. Шаблоны - это реализация статического полиморфизма в C++ (к слову, у статического полиморфизма с динамическим довольно мало общего, поэтому не стоит их обобщать). Шаблоны позволяют создателю класса (или функции, да, они тоже могут быть шаблонными) избежать решения о типе, который должен обрабатываться. Так, поле нашего класса может содержать какой-то заранее неизвестный тип `T`, или указатель `T*`:

```cpp
#include <iostream>

template<class T>
class MyClass {
	T my_field;
public:
	T get_my_field() { return my_field; }
};

int main() {
	MyClass<std::string> my_object;
	std::cout << my_object.get_my_field() << std::endl;
}
```

### Контейнеры

Контейнеры - это классы, которые энкапсулируют некую внутреннюю структуру, будь то массив, список или дерево. И снова примером станет `std::vector` - контейнер, энкапсулирующий динамический массив. Из интересных методов `std::vector` можно заметить `resize()`, `reserve()`, `push_back()`, `insert()`. Все они увеличивают количество хранимых данных, но операционная система не может постоянно добавлять память к уже выделенной. По итогу, вне поля зрения конечного пользователя контейнера происходят относительно сложные операции: выделение памяти, копирование старых данных в новый участок памяти, модификация внутренних полей контейнера.

Контейнеры задуманы как структура, из которой потом возможно достать хранимые элементы. Порой не удобно задумываться над внутренним устройством контейнера. Абстракция над этими соображениями представлена в C++ с помощью __итераторов__. На итераторы можно смотреть как на курсор в текстовом документе

### Реализация собственных итераторов

Итератор – это такой объект, который позволяет перебирать элементы контейнера, переходя от одного элемента к другому. Контейнеры поддерживают определенный тип итератора, который наделен своим собственным набором доступных операций. Библиотека итераторов в STL помогает соединить контейнеры STL вместе с алгоритмами STL. При этом и контейнеры и алгоритмы не завязаны друг на друга, связь осуществляется только через итераторы. На итераторы можно смотреть как на курсор, указывающий на текущий элемент. Этот курсор можно двигать относительно его текущей позиции, в зависимости от типа итератора, на различные смещения. Итератор в себе хранит ту информацию, которая ему необходима для доступа к элементу и выполнению сдвига. Для списка это может быть указатель на вершину, а для массива - это указатель на конкретный элемент.

Эти наборы отличаются и зависят от различных категорий итераторов:
* input\_iterator (Входной)
* output\_iterator (Выходной)
* forward\_iterator (Однонаправленный)
* bidirectional\_iterator (Двунаправленный)
* random\_access\_iterator (Произвольного доступа)
* contiguous\_iterator (Данные расположены последовательно в памяти)

Подробнее - https://en.cppreference.com/w/cpp/iterator

Различные типы итераторов "вложены" друг в друга, например `bidirectional_iterator` полностью имплементирует `forward_iterator`, `random_access_iterator` полностью имплементирует `forward_iterator`.

Чтобы реализовать собственный класс итератора, необходимо в нём задать псевдонимы типов:

```cpp
class Iterator {
	using iterator_concept [[maybe_unused]] = std::contiguous_iterator_tag;
    // ...
};
```

Здесь мы указываем, что наш итератор является итератором контейнера, элементы которого расположены последовательно в одном участке памяти (как в массиве) - https://en.cppreference.com/w/cpp/iterator/contiguous_iterator

Также необходимо реализовать сам итератор:

```cpp
xxclass Iterator {
	// тут будет псевдоним типа
	Iterator(/* данные для инициализации итератора */) {}
	~Iterator() {}
	T& operator*() {} // "разыменование" итератора
	const T& operator*() const {}
	Iterator& operator=(const Iterator&) {}
	
	// для forward_iterator
	bool operator==(const Iterator&) {}
	Iterator& operator++() {}
	
	// для bidirectional_iterator
	Iterator& operator--() {}
	
	// для random_access_iterator
	Iterator& operator+=(size_t) {}
	Iterator& operator-=(size_t) {}
	Iterator operator+(size_t) {}
	Iterator operator-(size_t) {}
	Iterator& operator[](size_t) {}
	
	bool operator<(const Iterator&) const {}
	bool operator>(const Iterator&) const {}
	bool operator<=(const Iterator&) const {}
	bool operator>=(const Iterator&) const {}
	// есть мегахак в C++20:
	// Возвращает -1, если меньше
	// Возвращает 0, если равно
	// Возвращает 1, если больше
	// bool operator<=>(const Iterator&) const {}
	// 
	// Реализовав этот оператор, все операторы сравнения
	// будут реализованы автоматически
	// Меньше кода, меньше хлопот!
	//
	// Довольно часто можно даже
	// bool operator<=>(const Iterator&) const = default;
};
```
	

Реализация методов и внутренней работы итераторов лежит на разработчке, и сильно зависит от того, для какого контейнера реализовывается данный итератор.
Например, для реализация итератора для класса `vector` будет очень похожа на работу с обычными указателями (объект итератора будет содержать указатель на элемент). Реализация же итератора для `map` будет более сложной и будет сильно зависеть от реализации структуры данных контейнера.

### Амортизированная сложность

Чтобы правильно реализовать класс `vector`, необзоимо необходимо узнать об амортизированной сложности метода `push_back`. Нет смысла пересказывать то, что уже хорошо описано. Поэтому предлагается самостоятельно ознакомится с этим понятием по ссылкам:
- [Выделение памяти под vector](http://alenacpp.blogspot.com/2005/06/vector_30.html)
- [Амортизированная сложность](https://www.coursera.org/lecture/c-plus-plus-red/amortizirovannaia-slozhnost-sGVxq)

Вкратце: `push_back` выделяет памяти больше, чем действительно нужно для одного элемента и не каждый раз, если это не необходимо. Поэтому в классе `vector` помимо поля `size` есть поле `capacity`

## Задание

1. Реализуйте аналог `std::vector`.
1. Обеспечте **амортизированную сложность O(1)** добавления элемента в конец вектора.
1. Проверьте код на наличие утечек памяти.
1. **Использовать `std::vector` запрещается.**
1. Проверьте, что ваша реализация правильно работает со стандартными алгоритмами STL (`std::sort`, `std::copy_if`, `std::find_if`).

### Методы для реализации
```cpp
template <class T>
class vector {
public:
    vector(); // конструктор по умолчанию
    vector(const vector<T>&); // конструктор копирования
    vector(size_t, const T&); // конструктор, заполняющий массив заданным значением
    ~vector(); // деструктор
    operator=(const vector<T>&); // оператор присваивания (копирования)

	constexpr T& operator[size_t]; // оператор индексации
	
	// необязательно, если хотите познакомиться с исключениями
	constexpr T& at(size_t); // безопасный оператор индексации (проверяет на выход за границы)
	
	constexpr T& front(); // первый элемент (безопасно)
	constexpr T& back(); // последний элемент (безопасно)
	constexpr T* data(); // низлежащий указатель

	constexpr vector::iterator begin(); // итератор на начало массива
	constexpr vector::iterator end(); // итератор на конец массива (элемент "после последнего")

	constexpr bool empty(); // проверка контейнера на пустоту
	constexpr size_t size(); // количество хранимых элементов
    constexpr void reserve(size_t); // выделение памяти для хранения элементов (предварительно)
    сonstexpr size_t capacity(); // количество элементов, которые массив может в себя вместить без реаллокаций

    constexpr void clear(); // очистка массива, освобождение памяти
	
	// необязательно, если хотите поиграться с памятью
    constexpr vector::iterator insert(const vector::iterator, const T&); // вставка элемента после поданного итератора
	
    constexpr void push_back(const T&); // вставка элемента в конец
    constexpr void pop_back(); // удаление элемента из конца массива
    constexpr void swap(vector<T>&); // обмен значений массивов
	
	class Iterator {
		// ...
	};
};
```

_Замечание_: `constexpr` в данном случае даёт компилятору знать, что функцию можно `inline`'ить. Так как при работе с контейнерами вызов функций довольно част, `inline` может сильно ускорить работу. В общем случае `constexpr` означает что выражение можно посчитать на этапе компиляции, для работы программы это кодовое слово не несёт значения
